<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MicrOS: library/src/stdio.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MicrOS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('stdio_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">stdio.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &quot;<a class="el" href="stdlib_8h_source.html">stdlib.h</a>&quot;</code><br />
</div>
<p><a href="stdio_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_l_e.html">FILE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object containing information to control a stream.  <a href="struct_f_i_l_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a72a591cf0a96cf23c63df5c78712dabe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a72a591cf0a96cf23c63df5c78712dabe">BUFSIZ</a>&#160;&#160;&#160;1024 * 32</td></tr>
<tr class="memdesc:a72a591cf0a96cf23c63df5c78712dabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the stream buffer.  <a href="#a72a591cf0a96cf23c63df5c78712dabe">More...</a><br /></td></tr>
<tr class="separator:a72a591cf0a96cf23c63df5c78712dabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59adc4c82490d23754cd39c2fb99b0da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a59adc4c82490d23754cd39c2fb99b0da">EOF</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:a59adc4c82490d23754cd39c2fb99b0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value returned when internal stream position has reached the end of file.  <a href="#a59adc4c82490d23754cd39c2fb99b0da">More...</a><br /></td></tr>
<tr class="separator:a59adc4c82490d23754cd39c2fb99b0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada6f64b4a36eb39c9b4cfd44eef7b36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#aada6f64b4a36eb39c9b4cfd44eef7b36">FILENAME_MAX</a>&#160;&#160;&#160;255</td></tr>
<tr class="memdesc:aada6f64b4a36eb39c9b4cfd44eef7b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of file names.  <a href="#aada6f64b4a36eb39c9b4cfd44eef7b36">More...</a><br /></td></tr>
<tr class="separator:aada6f64b4a36eb39c9b4cfd44eef7b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa188a2e288c10a684622814c51337465"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#aa188a2e288c10a684622814c51337465">FOPEN_MAX</a>&#160;&#160;&#160;INT32_MAX</td></tr>
<tr class="memdesc:aa188a2e288c10a684622814c51337465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Potential limit of simultaneous open streams.  <a href="#aa188a2e288c10a684622814c51337465">More...</a><br /></td></tr>
<tr class="separator:aa188a2e288c10a684622814c51337465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2560a07a7528c4975660f391320faca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ad2560a07a7528c4975660f391320faca">L_tmpnam</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ad2560a07a7528c4975660f391320faca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum length for temporary file name.  <a href="#ad2560a07a7528c4975660f391320faca">More...</a><br /></td></tr>
<tr class="separator:ad2560a07a7528c4975660f391320faca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7e63a6fb078a062192145950369d09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ada7e63a6fb078a062192145950369d09">TMP_MAX</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ada7e63a6fb078a062192145950369d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of temporary files.  <a href="#ada7e63a6fb078a062192145950369d09">More...</a><br /></td></tr>
<tr class="separator:ada7e63a6fb078a062192145950369d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d112bae8fd35be772185b6ec6bcbe64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a0d112bae8fd35be772185b6ec6bcbe64">SEEK_SET</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a0d112bae8fd35be772185b6ec6bcbe64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek-Set mode (position is absolute)  <a href="#a0d112bae8fd35be772185b6ec6bcbe64">More...</a><br /></td></tr>
<tr class="separator:a0d112bae8fd35be772185b6ec6bcbe64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8d0b76b470ba65a43ca46a88320f39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a4c8d0b76b470ba65a43ca46a88320f39">SEEK_CUR</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a4c8d0b76b470ba65a43ca46a88320f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek-Current mode (relative to the current position)  <a href="#a4c8d0b76b470ba65a43ca46a88320f39">More...</a><br /></td></tr>
<tr class="separator:a4c8d0b76b470ba65a43ca46a88320f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a2e6c114780c3071efd24f16c7f7d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ad2a2e6c114780c3071efd24f16c7f7d8">SEEK_END</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ad2a2e6c114780c3071efd24f16c7f7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek-End mode (relative to the end of the file)  <a href="#ad2a2e6c114780c3071efd24f16c7f7d8">More...</a><br /></td></tr>
<tr class="separator:ad2a2e6c114780c3071efd24f16c7f7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8661edb6b53e3104bef089bef02d0508"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a8661edb6b53e3104bef089bef02d0508">_IONBF</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a8661edb6b53e3104bef089bef02d0508"><td class="mdescLeft">&#160;</td><td class="mdescRight">No Buffering mode.  <a href="#a8661edb6b53e3104bef089bef02d0508">More...</a><br /></td></tr>
<tr class="separator:a8661edb6b53e3104bef089bef02d0508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9e52813bd224e4519e0b1289abbce9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#aca9e52813bd224e4519e0b1289abbce9">_IOLBF</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:aca9e52813bd224e4519e0b1289abbce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Line Buffering mode.  <a href="#aca9e52813bd224e4519e0b1289abbce9">More...</a><br /></td></tr>
<tr class="separator:aca9e52813bd224e4519e0b1289abbce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7475971eb93ce0184379e71fe7626e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#af7475971eb93ce0184379e71fe7626e9">_IOFBF</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:af7475971eb93ce0184379e71fe7626e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full Buffering mode.  <a href="#af7475971eb93ce0184379e71fe7626e9">More...</a><br /></td></tr>
<tr class="separator:af7475971eb93ce0184379e71fe7626e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a29d85914ddff32967d85ada69854206d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="string_8h.html#aeb1e3f10c6300966c4b38a14295b7c4a">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a></td></tr>
<tr class="memdesc:a29d85914ddff32967d85ada69854206d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integral type.  <a href="#a29d85914ddff32967d85ada69854206d">More...</a><br /></td></tr>
<tr class="separator:a29d85914ddff32967d85ada69854206d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8024575832cf578e21406fbb1a7dc2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="string_8h.html#aeb1e3f10c6300966c4b38a14295b7c4a">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a8d8024575832cf578e21406fbb1a7dc2">fpos_t</a></td></tr>
<tr class="memdesc:a8d8024575832cf578e21406fbb1a7dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object containing information to specify a position within a file.  <a href="#a8d8024575832cf578e21406fbb1a7dc2">More...</a><br /></td></tr>
<tr class="separator:a8d8024575832cf578e21406fbb1a7dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:acb05a32f5243d8628ef7a25962d73112"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#acb05a32f5243d8628ef7a25962d73112">file_buffering_mode</a> { <a class="el" href="stdio_8h.html#acb05a32f5243d8628ef7a25962d73112a631f4ab3b7bc6c1ba76460d4e717b834">file_buffering_mode_none</a> = 0, 
<a class="el" href="stdio_8h.html#acb05a32f5243d8628ef7a25962d73112a8807f13dfef5b47fc4ecec71c613be41">file_buffering_mode_line</a> = 1, 
<a class="el" href="stdio_8h.html#acb05a32f5243d8628ef7a25962d73112a862579f21f529750c01ecd9fbf072184">file_buffering_mode_full</a> = 2
 }<tr class="memdesc:acb05a32f5243d8628ef7a25962d73112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream buffering modest.  <a href="stdio_8h.html#acb05a32f5243d8628ef7a25962d73112">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:acb05a32f5243d8628ef7a25962d73112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588666511dde277029c4c5afc30782a6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a588666511dde277029c4c5afc30782a6">file_mode</a> { <br />
&#160;&#160;<a class="el" href="stdio_8h.html#a588666511dde277029c4c5afc30782a6aa097fa3fa2b7f1bbe90f5fd496f7b376">file_mode_none</a>, 
<a class="el" href="stdio_8h.html#a588666511dde277029c4c5afc30782a6a9684de9e6f60f64d578d6c8e6bf842a4">file_mode_read</a>, 
<a class="el" href="stdio_8h.html#a588666511dde277029c4c5afc30782a6aad764964760fd116c5c4d031858a2868">file_mode_write</a>, 
<a class="el" href="stdio_8h.html#a588666511dde277029c4c5afc30782a6ad15067df7edbf064eab3cfcbd2537047">file_mode_append</a>, 
<br />
&#160;&#160;<a class="el" href="stdio_8h.html#a588666511dde277029c4c5afc30782a6a205f7ed9faf4ecdf6c2bac2cadb9de9f">file_mode_read_and_update</a>, 
<a class="el" href="stdio_8h.html#a588666511dde277029c4c5afc30782a6a1d8609421b675c8553cb555edcf56d6a">file_mode_write_and_update</a>, 
<a class="el" href="stdio_8h.html#a588666511dde277029c4c5afc30782a6a7812fa87d3b65cb59181d41d64a935a2">file_mode_append_and_update</a>
<br />
 }</td></tr>
<tr class="separator:a588666511dde277029c4c5afc30782a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2ff9908f035aec76a33f9792faf9d402"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a2ff9908f035aec76a33f9792faf9d402">remove</a> (const char *filename)</td></tr>
<tr class="memdesc:a2ff9908f035aec76a33f9792faf9d402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove file.  <a href="#a2ff9908f035aec76a33f9792faf9d402">More...</a><br /></td></tr>
<tr class="separator:a2ff9908f035aec76a33f9792faf9d402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd46c92931ef1c646e1a78ab880a00e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#affd46c92931ef1c646e1a78ab880a00e">rename</a> (const char *oldname, const char *newname)</td></tr>
<tr class="memdesc:affd46c92931ef1c646e1a78ab880a00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename file.  <a href="#affd46c92931ef1c646e1a78ab880a00e">More...</a><br /></td></tr>
<tr class="separator:affd46c92931ef1c646e1a78ab880a00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffa3e442e49895773d564f422e1be1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#afffa3e442e49895773d564f422e1be1c">fopen</a> (const char *filename, const char *<a class="el" href="vga__gmode_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>)</td></tr>
<tr class="memdesc:afffa3e442e49895773d564f422e1be1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open file.  <a href="#afffa3e442e49895773d564f422e1be1c">More...</a><br /></td></tr>
<tr class="separator:afffa3e442e49895773d564f422e1be1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f86d3747887e65d7d02e4792030fad0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a7f86d3747887e65d7d02e4792030fad0">freopen</a> (const char *filename, const char *<a class="el" href="vga__gmode_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>, <a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:a7f86d3747887e65d7d02e4792030fad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reopen stream with different file or mode.  <a href="#a7f86d3747887e65d7d02e4792030fad0">More...</a><br /></td></tr>
<tr class="separator:a7f86d3747887e65d7d02e4792030fad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76370407f9ab0402564c2bb9bc9664e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a76370407f9ab0402564c2bb9bc9664e0">fclose</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:a76370407f9ab0402564c2bb9bc9664e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close file.  <a href="#a76370407f9ab0402564c2bb9bc9664e0">More...</a><br /></td></tr>
<tr class="separator:a76370407f9ab0402564c2bb9bc9664e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb974f28765a31026ee6bf71d5175951"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#adb974f28765a31026ee6bf71d5175951">fflush</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:adb974f28765a31026ee6bf71d5175951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush stream.  <a href="#adb974f28765a31026ee6bf71d5175951">More...</a><br /></td></tr>
<tr class="separator:adb974f28765a31026ee6bf71d5175951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad886fefb32f6ec9ad47122fe5dfd916d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ad886fefb32f6ec9ad47122fe5dfd916d">setbuf</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream, char *<a class="el" href="physical__memory__manager_8c.html#ae802f58de30643b3dfc87bff25f18b20">buffer</a>)</td></tr>
<tr class="memdesc:ad886fefb32f6ec9ad47122fe5dfd916d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stream buffer.  <a href="#ad886fefb32f6ec9ad47122fe5dfd916d">More...</a><br /></td></tr>
<tr class="separator:ad886fefb32f6ec9ad47122fe5dfd916d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92132979bde440e7f335dc6b030eded0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a92132979bde440e7f335dc6b030eded0">setvbuf</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream, char *<a class="el" href="physical__memory__manager_8c.html#ae802f58de30643b3dfc87bff25f18b20">buffer</a>, int <a class="el" href="vga__gmode_8c.html#a000e34997df38c2005a83d63e67d9282">mode</a>, <a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a> size)</td></tr>
<tr class="memdesc:a92132979bde440e7f335dc6b030eded0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change stream buffering.  <a href="#a92132979bde440e7f335dc6b030eded0">More...</a><br /></td></tr>
<tr class="separator:a92132979bde440e7f335dc6b030eded0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11a990e4f8863a1e7736e3c1d430092"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ab11a990e4f8863a1e7736e3c1d430092">fgetc</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:ab11a990e4f8863a1e7736e3c1d430092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get character from stream.  <a href="#ab11a990e4f8863a1e7736e3c1d430092">More...</a><br /></td></tr>
<tr class="separator:ab11a990e4f8863a1e7736e3c1d430092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0020b6e39df31f8b342a2444b9b4ad31"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a0020b6e39df31f8b342a2444b9b4ad31">fgets</a> (char *str, int num, <a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:a0020b6e39df31f8b342a2444b9b4ad31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get string from stream.  <a href="#a0020b6e39df31f8b342a2444b9b4ad31">More...</a><br /></td></tr>
<tr class="separator:a0020b6e39df31f8b342a2444b9b4ad31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ef96e1095a75e6ea7db32d07e06682"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a85ef96e1095a75e6ea7db32d07e06682">fputc</a> (int character, <a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:a85ef96e1095a75e6ea7db32d07e06682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write character to stream.  <a href="#a85ef96e1095a75e6ea7db32d07e06682">More...</a><br /></td></tr>
<tr class="separator:a85ef96e1095a75e6ea7db32d07e06682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b4ead021aa4b215a292baf04bb9638"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a11b4ead021aa4b215a292baf04bb9638">fputs</a> (const char *str, <a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:a11b4ead021aa4b215a292baf04bb9638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write string to stream.  <a href="#a11b4ead021aa4b215a292baf04bb9638">More...</a><br /></td></tr>
<tr class="separator:a11b4ead021aa4b215a292baf04bb9638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a0ea2c21a23a380b7c30fe35fa9456"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ad5a0ea2c21a23a380b7c30fe35fa9456">getc</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:ad5a0ea2c21a23a380b7c30fe35fa9456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get character from stream.  <a href="#ad5a0ea2c21a23a380b7c30fe35fa9456">More...</a><br /></td></tr>
<tr class="separator:ad5a0ea2c21a23a380b7c30fe35fa9456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45fdeab51c3197c1e7c4ec7beabaca9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ac45fdeab51c3197c1e7c4ec7beabaca9">getchar</a> ()</td></tr>
<tr class="memdesc:ac45fdeab51c3197c1e7c4ec7beabaca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get character from stdin.  <a href="#ac45fdeab51c3197c1e7c4ec7beabaca9">More...</a><br /></td></tr>
<tr class="separator:ac45fdeab51c3197c1e7c4ec7beabaca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23cf6ce344e3cdbbe53eee7e9a83b5c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ad23cf6ce344e3cdbbe53eee7e9a83b5c">gets</a> (char *str)</td></tr>
<tr class="memdesc:ad23cf6ce344e3cdbbe53eee7e9a83b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get string from stdin.  <a href="#ad23cf6ce344e3cdbbe53eee7e9a83b5c">More...</a><br /></td></tr>
<tr class="separator:ad23cf6ce344e3cdbbe53eee7e9a83b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe402db9691d3b23117e664ddef88baa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#afe402db9691d3b23117e664ddef88baa">putc</a> (int character, <a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:afe402db9691d3b23117e664ddef88baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write character to stream.  <a href="#afe402db9691d3b23117e664ddef88baa">More...</a><br /></td></tr>
<tr class="separator:afe402db9691d3b23117e664ddef88baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb174a8122023129dc9abbbed04d88fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#afb174a8122023129dc9abbbed04d88fd">putchar</a> (int character)</td></tr>
<tr class="memdesc:afb174a8122023129dc9abbbed04d88fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write character to stdout.  <a href="#afb174a8122023129dc9abbbed04d88fd">More...</a><br /></td></tr>
<tr class="separator:afb174a8122023129dc9abbbed04d88fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24df0c04767d20bfc8337baa088605ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a24df0c04767d20bfc8337baa088605ff">puts</a> (const char *str)</td></tr>
<tr class="memdesc:a24df0c04767d20bfc8337baa088605ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write string to stdout.  <a href="#a24df0c04767d20bfc8337baa088605ff">More...</a><br /></td></tr>
<tr class="separator:a24df0c04767d20bfc8337baa088605ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77a6a7c369c033e56b15696cc5d2415"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ad77a6a7c369c033e56b15696cc5d2415">ungetc</a> (int character, <a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:ad77a6a7c369c033e56b15696cc5d2415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unget character from stream.  <a href="#ad77a6a7c369c033e56b15696cc5d2415">More...</a><br /></td></tr>
<tr class="separator:ad77a6a7c369c033e56b15696cc5d2415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8cb08b18c9b9ed78d1598c8076d956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#afb8cb08b18c9b9ed78d1598c8076d956">fread</a> (void *ptr, <a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a> size, <a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a> count, <a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:afb8cb08b18c9b9ed78d1598c8076d956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read block of data from stream.  <a href="#afb8cb08b18c9b9ed78d1598c8076d956">More...</a><br /></td></tr>
<tr class="separator:afb8cb08b18c9b9ed78d1598c8076d956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998dde93aaae1ed6cc10a4656eb5cc10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a998dde93aaae1ed6cc10a4656eb5cc10">fwrite</a> (const void *ptr, <a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a> size, <a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a> count, <a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:a998dde93aaae1ed6cc10a4656eb5cc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write block of data to stream.  <a href="#a998dde93aaae1ed6cc10a4656eb5cc10">More...</a><br /></td></tr>
<tr class="separator:a998dde93aaae1ed6cc10a4656eb5cc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e2b1a01359f5f7068b61d1dffcdcdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#af2e2b1a01359f5f7068b61d1dffcdcdd">fgetpos</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream, <a class="el" href="stdio_8h.html#a8d8024575832cf578e21406fbb1a7dc2">fpos_t</a> *pos)</td></tr>
<tr class="memdesc:af2e2b1a01359f5f7068b61d1dffcdcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current position in stream.  <a href="#af2e2b1a01359f5f7068b61d1dffcdcdd">More...</a><br /></td></tr>
<tr class="separator:af2e2b1a01359f5f7068b61d1dffcdcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b5e837a27524264f0422232f5f9538"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#af2b5e837a27524264f0422232f5f9538">fseek</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream, long int offset, int origin)</td></tr>
<tr class="memdesc:af2b5e837a27524264f0422232f5f9538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reposition stream position indicator.  <a href="#af2b5e837a27524264f0422232f5f9538">More...</a><br /></td></tr>
<tr class="separator:af2b5e837a27524264f0422232f5f9538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76eb887fc5fbc842c2fb977dd926848c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a76eb887fc5fbc842c2fb977dd926848c">fsetpos</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream, const <a class="el" href="stdio_8h.html#a8d8024575832cf578e21406fbb1a7dc2">fpos_t</a> *pos)</td></tr>
<tr class="memdesc:a76eb887fc5fbc842c2fb977dd926848c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position indicator of stream.  <a href="#a76eb887fc5fbc842c2fb977dd926848c">More...</a><br /></td></tr>
<tr class="separator:a76eb887fc5fbc842c2fb977dd926848c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6273f71322efc95f429d9e990a8ef8ae"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a6273f71322efc95f429d9e990a8ef8ae">ftell</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:a6273f71322efc95f429d9e990a8ef8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current position in stream.  <a href="#a6273f71322efc95f429d9e990a8ef8ae">More...</a><br /></td></tr>
<tr class="separator:a6273f71322efc95f429d9e990a8ef8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cd401f198d33d9d01a9e8aa4026819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#aa0cd401f198d33d9d01a9e8aa4026819">rewind</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:aa0cd401f198d33d9d01a9e8aa4026819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set position of stream to the beginning.  <a href="#aa0cd401f198d33d9d01a9e8aa4026819">More...</a><br /></td></tr>
<tr class="separator:aa0cd401f198d33d9d01a9e8aa4026819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5de865c3093158c70bf4bd88a9deea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ab5de865c3093158c70bf4bd88a9deea5">clearerr</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:ab5de865c3093158c70bf4bd88a9deea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear error indicators.  <a href="#ab5de865c3093158c70bf4bd88a9deea5">More...</a><br /></td></tr>
<tr class="separator:ab5de865c3093158c70bf4bd88a9deea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e71f513ad2496acb5361aedc065e3d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a9e71f513ad2496acb5361aedc065e3d8">feof</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:a9e71f513ad2496acb5361aedc065e3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check end-of-file indicator.  <a href="#a9e71f513ad2496acb5361aedc065e3d8">More...</a><br /></td></tr>
<tr class="separator:a9e71f513ad2496acb5361aedc065e3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a98383bb54291c2abede7aa28acf597"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a4a98383bb54291c2abede7aa28acf597">ferror</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream)</td></tr>
<tr class="memdesc:a4a98383bb54291c2abede7aa28acf597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check error indicator.  <a href="#a4a98383bb54291c2abede7aa28acf597">More...</a><br /></td></tr>
<tr class="separator:a4a98383bb54291c2abede7aa28acf597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38eb7b0b01f7de79166633fd2fe0459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#af38eb7b0b01f7de79166633fd2fe0459">perror</a> (const char *str)</td></tr>
<tr class="memdesc:af38eb7b0b01f7de79166633fd2fe0459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print error message.  <a href="#af38eb7b0b01f7de79166633fd2fe0459">More...</a><br /></td></tr>
<tr class="separator:af38eb7b0b01f7de79166633fd2fe0459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3082155ec11e7229f7a20439b31a169e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a3082155ec11e7229f7a20439b31a169e">sprintf</a> (char *str, const char *format,...)</td></tr>
<tr class="memdesc:a3082155ec11e7229f7a20439b31a169e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write formatted data to string.  <a href="#a3082155ec11e7229f7a20439b31a169e">More...</a><br /></td></tr>
<tr class="separator:a3082155ec11e7229f7a20439b31a169e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98631211a4a8aee62f572375d5b637be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a98631211a4a8aee62f572375d5b637be">printf</a> (const char *format,...)</td></tr>
<tr class="memdesc:a98631211a4a8aee62f572375d5b637be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print formatted data to stdout.  <a href="#a98631211a4a8aee62f572375d5b637be">More...</a><br /></td></tr>
<tr class="separator:a98631211a4a8aee62f572375d5b637be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41ff60ab072068a0f730c6da6cf1ce9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ae41ff60ab072068a0f730c6da6cf1ce9">fprintf</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *file, const char *format,...)</td></tr>
<tr class="memdesc:ae41ff60ab072068a0f730c6da6cf1ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print formatted data to stdoutWrite formatted data to stream.  <a href="#ae41ff60ab072068a0f730c6da6cf1ce9">More...</a><br /></td></tr>
<tr class="separator:ae41ff60ab072068a0f730c6da6cf1ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238ba3ae728d117984e087d9db33cd13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a238ba3ae728d117984e087d9db33cd13">vfprintf</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream, const char *format, va_list arg)</td></tr>
<tr class="memdesc:a238ba3ae728d117984e087d9db33cd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print formatted data from variable argument list to stream.  <a href="#a238ba3ae728d117984e087d9db33cd13">More...</a><br /></td></tr>
<tr class="separator:a238ba3ae728d117984e087d9db33cd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b037e5e1db404842a42cd8e9cecaddb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a2b037e5e1db404842a42cd8e9cecaddb">vprintf</a> (const char *format, va_list arg)</td></tr>
<tr class="memdesc:a2b037e5e1db404842a42cd8e9cecaddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print formatted data from variable argument list to stdout.  <a href="#a2b037e5e1db404842a42cd8e9cecaddb">More...</a><br /></td></tr>
<tr class="separator:a2b037e5e1db404842a42cd8e9cecaddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8cce030b12942981147c40e4c77b37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ade8cce030b12942981147c40e4c77b37">vsprintf</a> (char *str, const char *format, va_list arg)</td></tr>
<tr class="memdesc:ade8cce030b12942981147c40e4c77b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print formatted data from variable argument list to string.  <a href="#ade8cce030b12942981147c40e4c77b37">More...</a><br /></td></tr>
<tr class="separator:ade8cce030b12942981147c40e4c77b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb0fd1f97e393175a27829805cbff92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#aadb0fd1f97e393175a27829805cbff92">vfscanf</a> (<a class="el" href="struct_f_i_l_e.html">FILE</a> *stream, const char *format, va_list arg)</td></tr>
<tr class="memdesc:aadb0fd1f97e393175a27829805cbff92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read formatted data from stream into variable argument list.  <a href="#aadb0fd1f97e393175a27829805cbff92">More...</a><br /></td></tr>
<tr class="separator:aadb0fd1f97e393175a27829805cbff92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c48433db9c04031772d5b36e6c4411d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a5c48433db9c04031772d5b36e6c4411d">scanf</a> (const char *format,...)</td></tr>
<tr class="memdesc:a5c48433db9c04031772d5b36e6c4411d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read formatted data from stdin.  <a href="#a5c48433db9c04031772d5b36e6c4411d">More...</a><br /></td></tr>
<tr class="separator:a5c48433db9c04031772d5b36e6c4411d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5cde325c6bb1e30e2e4500f9cc91b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ade5cde325c6bb1e30e2e4500f9cc91b1">__stdio_create_stream</a> ()</td></tr>
<tr class="memdesc:ade5cde325c6bb1e30e2e4500f9cc91b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new stream.  <a href="#ade5cde325c6bb1e30e2e4500f9cc91b1">More...</a><br /></td></tr>
<tr class="separator:ade5cde325c6bb1e30e2e4500f9cc91b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184137f4115a7fa8ff43aff980d67f37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdio_8h.html#a588666511dde277029c4c5afc30782a6">file_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#a184137f4115a7fa8ff43aff980d67f37">__stdio_get_file_mode</a> (const char *str_mode)</td></tr>
<tr class="memdesc:a184137f4115a7fa8ff43aff980d67f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses file mode.  <a href="#a184137f4115a7fa8ff43aff980d67f37">More...</a><br /></td></tr>
<tr class="separator:a184137f4115a7fa8ff43aff980d67f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:acab9c1fe2a80b10e01858bda28a04244"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#acab9c1fe2a80b10e01858bda28a04244">stdin</a></td></tr>
<tr class="memdesc:acab9c1fe2a80b10e01858bda28a04244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard input (default is keyboard).  <a href="#acab9c1fe2a80b10e01858bda28a04244">More...</a><br /></td></tr>
<tr class="separator:acab9c1fe2a80b10e01858bda28a04244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80f4484175bf6c48d7b7ca4e9897ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ac80f4484175bf6c48d7b7ca4e9897ae6">stdout</a></td></tr>
<tr class="memdesc:ac80f4484175bf6c48d7b7ca4e9897ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard output (default is console).  <a href="#ac80f4484175bf6c48d7b7ca4e9897ae6">More...</a><br /></td></tr>
<tr class="separator:ac80f4484175bf6c48d7b7ca4e9897ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e47c346a25e2e7edd2c9b4ca5d0262"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="stdio_8h.html#ac9e47c346a25e2e7edd2c9b4ca5d0262">stderr</a></td></tr>
<tr class="memdesc:ac9e47c346a25e2e7edd2c9b4ca5d0262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard error output (default is console).  <a href="#ac9e47c346a25e2e7edd2c9b4ca5d0262">More...</a><br /></td></tr>
<tr class="separator:ac9e47c346a25e2e7edd2c9b4ca5d0262"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af7475971eb93ce0184379e71fe7626e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7475971eb93ce0184379e71fe7626e9">&#9670;&nbsp;</a></span>_IOFBF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _IOFBF&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full Buffering mode. </p>

</div>
</div>
<a id="aca9e52813bd224e4519e0b1289abbce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9e52813bd224e4519e0b1289abbce9">&#9670;&nbsp;</a></span>_IOLBF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _IOLBF&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Line Buffering mode. </p>

</div>
</div>
<a id="a8661edb6b53e3104bef089bef02d0508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8661edb6b53e3104bef089bef02d0508">&#9670;&nbsp;</a></span>_IONBF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _IONBF&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No Buffering mode. </p>

</div>
</div>
<a id="a72a591cf0a96cf23c63df5c78712dabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a591cf0a96cf23c63df5c78712dabe">&#9670;&nbsp;</a></span>BUFSIZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFSIZ&#160;&#160;&#160;1024 * 32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of the stream buffer. </p>

</div>
</div>
<a id="a59adc4c82490d23754cd39c2fb99b0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59adc4c82490d23754cd39c2fb99b0da">&#9670;&nbsp;</a></span>EOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EOF&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value returned when internal stream position has reached the end of file. </p>

</div>
</div>
<a id="aada6f64b4a36eb39c9b4cfd44eef7b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada6f64b4a36eb39c9b4cfd44eef7b36">&#9670;&nbsp;</a></span>FILENAME_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FILENAME_MAX&#160;&#160;&#160;255</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum length of file names. </p>

</div>
</div>
<a id="aa188a2e288c10a684622814c51337465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa188a2e288c10a684622814c51337465">&#9670;&nbsp;</a></span>FOPEN_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FOPEN_MAX&#160;&#160;&#160;INT32_MAX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Potential limit of simultaneous open streams. </p>

</div>
</div>
<a id="ad2560a07a7528c4975660f391320faca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2560a07a7528c4975660f391320faca">&#9670;&nbsp;</a></span>L_tmpnam</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define L_tmpnam&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum length for temporary file name. </p>

</div>
</div>
<a id="a4c8d0b76b470ba65a43ca46a88320f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8d0b76b470ba65a43ca46a88320f39">&#9670;&nbsp;</a></span>SEEK_CUR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SEEK_CUR&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek-Current mode (relative to the current position) </p>

</div>
</div>
<a id="ad2a2e6c114780c3071efd24f16c7f7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a2e6c114780c3071efd24f16c7f7d8">&#9670;&nbsp;</a></span>SEEK_END</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SEEK_END&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek-End mode (relative to the end of the file) </p>

</div>
</div>
<a id="a0d112bae8fd35be772185b6ec6bcbe64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d112bae8fd35be772185b6ec6bcbe64">&#9670;&nbsp;</a></span>SEEK_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SEEK_SET&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek-Set mode (position is absolute) </p>

</div>
</div>
<a id="ada7e63a6fb078a062192145950369d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7e63a6fb078a062192145950369d09">&#9670;&nbsp;</a></span>TMP_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TMP_MAX&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of temporary files. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8d8024575832cf578e21406fbb1a7dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8024575832cf578e21406fbb1a7dc2">&#9670;&nbsp;</a></span>fpos_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="string_8h.html#aeb1e3f10c6300966c4b38a14295b7c4a">uint32_t</a> <a class="el" href="stdio_8h.html#a8d8024575832cf578e21406fbb1a7dc2">fpos_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Object containing information to specify a position within a file. </p>

</div>
</div>
<a id="a29d85914ddff32967d85ada69854206d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d85914ddff32967d85ada69854206d">&#9670;&nbsp;</a></span>size_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="string_8h.html#aeb1e3f10c6300966c4b38a14295b7c4a">uint32_t</a> <a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unsigned integral type. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="acb05a32f5243d8628ef7a25962d73112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb05a32f5243d8628ef7a25962d73112">&#9670;&nbsp;</a></span>file_buffering_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="stdio_8h.html#acb05a32f5243d8628ef7a25962d73112">file_buffering_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream buffering modest. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acb05a32f5243d8628ef7a25962d73112a631f4ab3b7bc6c1ba76460d4e717b834"></a>file_buffering_mode_none&#160;</td><td class="fielddoc"><p>Flush when new data is present (don't store it in buffer). </p>
</td></tr>
<tr><td class="fieldname"><a id="acb05a32f5243d8628ef7a25962d73112a8807f13dfef5b47fc4ecec71c613be41"></a>file_buffering_mode_line&#160;</td><td class="fielddoc"><p>Flush if buffer is full, new line char is present or fflush has been called. </p>
</td></tr>
<tr><td class="fieldname"><a id="acb05a32f5243d8628ef7a25962d73112a862579f21f529750c01ecd9fbf072184"></a>file_buffering_mode_full&#160;</td><td class="fielddoc"><p>Flush if buffer is full or fflush has been called. </p>
</td></tr>
</table>

</div>
</div>
<a id="a588666511dde277029c4c5afc30782a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588666511dde277029c4c5afc30782a6">&#9670;&nbsp;</a></span>file_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="stdio_8h.html#a588666511dde277029c4c5afc30782a6">file_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a588666511dde277029c4c5afc30782a6aa097fa3fa2b7f1bbe90f5fd496f7b376"></a>file_mode_none&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a588666511dde277029c4c5afc30782a6a9684de9e6f60f64d578d6c8e6bf842a4"></a>file_mode_read&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a588666511dde277029c4c5afc30782a6aad764964760fd116c5c4d031858a2868"></a>file_mode_write&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a588666511dde277029c4c5afc30782a6ad15067df7edbf064eab3cfcbd2537047"></a>file_mode_append&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a588666511dde277029c4c5afc30782a6a205f7ed9faf4ecdf6c2bac2cadb9de9f"></a>file_mode_read_and_update&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a588666511dde277029c4c5afc30782a6a1d8609421b675c8553cb555edcf56d6a"></a>file_mode_write_and_update&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a588666511dde277029c4c5afc30782a6a7812fa87d3b65cb59181d41d64a935a2"></a>file_mode_append_and_update&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ade5cde325c6bb1e30e2e4500f9cc91b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5cde325c6bb1e30e2e4500f9cc91b1">&#9670;&nbsp;</a></span>__stdio_create_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_f_i_l_e.html">FILE</a>* __stdio_create_stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates new stream. </p>
<p>Creates new stream (not assigned to any file or device) and returns it. </p><dl class="section return"><dt>Returns</dt><dd>A newly created stream. </dd></dl>

</div>
</div>
<a id="a184137f4115a7fa8ff43aff980d67f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184137f4115a7fa8ff43aff980d67f37">&#9670;&nbsp;</a></span>__stdio_get_file_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdio_8h.html#a588666511dde277029c4c5afc30782a6">file_mode</a> __stdio_get_file_mode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses file mode. </p>
<p>Parses file mode in string format (eg. r+) and returns corresponding enum. </p><dl class="section return"><dt>Returns</dt><dd>File mode in enum representation. </dd></dl>

</div>
</div>
<a id="ab5de865c3093158c70bf4bd88a9deea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5de865c3093158c70bf4bd88a9deea5">&#9670;&nbsp;</a></span>clearerr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearerr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear error indicators. </p>
<p>Resets both the error and the eof indicators of the stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76370407f9ab0402564c2bb9bc9664e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76370407f9ab0402564c2bb9bc9664e0">&#9670;&nbsp;</a></span>fclose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close file. </p>
<p>Closes the file associated with the stream and disassociates it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the stream is successfully closed, a zero value is returned. On failure, EOF is returned. </dd></dl>

</div>
</div>
<a id="a9e71f513ad2496acb5361aedc065e3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e71f513ad2496acb5361aedc065e3d8">&#9670;&nbsp;</a></span>feof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int feof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check end-of-file indicator. </p>
<p>Checks whether the end-of-File indicator associated with stream is set, returning a value different from zero if it is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-zero value is returned in the case that the end-of-file indicator associated with the stream is set. Otherwise, zero is returned. </dd></dl>

</div>
</div>
<a id="a4a98383bb54291c2abede7aa28acf597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a98383bb54291c2abede7aa28acf597">&#9670;&nbsp;</a></span>ferror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ferror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check error indicator. </p>
<p>Checks if the error indicator associated with stream is set, returning a value different from zero if it is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sstream</td><td>tream Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-zero value is returned in the case that the error indicator associated with the stream is set. Otherwise, zero is returned. </dd></dl>

</div>
</div>
<a id="adb974f28765a31026ee6bf71d5175951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb974f28765a31026ee6bf71d5175951">&#9670;&nbsp;</a></span>fflush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fflush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush stream. </p>
<p>If the given stream was open for writing any unwritten data in its output buffer is written to the file. If stream is a null pointer, all such streams are flushed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A zero value indicates success. If an error occurs, EOF is returned and the error indicator is set. </dd></dl>

</div>
</div>
<a id="ab11a990e4f8863a1e7736e3c1d430092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11a990e4f8863a1e7736e3c1d430092">&#9670;&nbsp;</a></span>fgetc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fgetc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get character from stream. </p>
<p>Returns the character currently pointed by the internal file position indicator of the specified stream. The internal file position indicator is then advanced to the next character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the character read is returned. If the position indicator was at the end-of-file, the function returns EOF. </dd></dl>

</div>
</div>
<a id="af2e2b1a01359f5f7068b61d1dffcdcdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e2b1a01359f5f7068b61d1dffcdcdd">&#9670;&nbsp;</a></span>fgetpos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fgetpos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdio_8h.html#a8d8024575832cf578e21406fbb1a7dc2">fpos_t</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current position in stream. </p>
<p>Retrieves the current position in the stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to a fpos_t object. This should point to an object already allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the function returns zero. In case of error, errno is set to a platform-specific positive value and the function returns a non-zero value. </dd></dl>

</div>
</div>
<a id="a0020b6e39df31f8b342a2444b9b4ad31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0020b6e39df31f8b342a2444b9b4ad31">&#9670;&nbsp;</a></span>fgets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* fgets </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get string from stream. </p>
<p>Reads characters from stream and stores them as a C string into str until (num-1) characters have been read or either a newline or the end-of-file is reached, whichever happens first. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to an array of chars where the string read is copied. </td></tr>
    <tr><td class="paramname">num</td><td>Maximum number of characters to be copied into str (including the terminating null-character). </td></tr>
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the function returns str. If the end-of-file is encountered while attempting to read a character, the eof indicator is set. If this happens before any characters could be read, the pointer returned is a null pointer. </dd></dl>

</div>
</div>
<a id="afffa3e442e49895773d564f422e1be1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffa3e442e49895773d564f422e1be1c">&#9670;&nbsp;</a></span>fopen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_f_i_l_e.html">FILE</a>* fopen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open file. </p>
<p>Opens the file whose name is specified in the parameter filename and associates it with a stream that can be identified in future operations by the <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> pointer returned. The returned stream is fully buffered by default. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>C string containing the name of the file to be opened. </td></tr>
    <tr><td class="paramname">mode</td><td>C string containing a file access mode (r, w, a, r+, w+, a+). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the file is successfully opened, the function returns a pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that can be used to identify the stream on future operations. Otherwise, a null pointer is returned. </dd></dl>

</div>
</div>
<a id="ae41ff60ab072068a0f730c6da6cf1ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41ff60ab072068a0f730c6da6cf1ce9">&#9670;&nbsp;</a></span>fprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fprintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print formatted data to stdoutWrite formatted data to stream. </p>
<p>Writes the C string pointed by format to the stream. If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies an output stream. </td></tr>
    <tr><td class="paramname">format</td><td>C string that contains the text to be written to the stream.Can contain embedded format specifiers. </td></tr>
    <tr><td class="paramname">...</td><td>Additional arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of characters written to stream. </dd></dl>

</div>
</div>
<a id="a85ef96e1095a75e6ea7db32d07e06682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ef96e1095a75e6ea7db32d07e06682">&#9670;&nbsp;</a></span>fputc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fputc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write character to stream. </p>
<p>Writes a character to the stream and advances the position indicator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The int promotion of the character to be written. </td></tr>
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the character written is returned. If a writing error occurs, EOF is returned and the error indicator (ferror) is set. </dd></dl>

</div>
</div>
<a id="a11b4ead021aa4b215a292baf04bb9638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b4ead021aa4b215a292baf04bb9638">&#9670;&nbsp;</a></span>fputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fputs </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write string to stream. </p>
<p>Writes the C string pointed by str to the stream. The function begins copying from the address specified (str) until it reaches the terminating null character ('\0'). This terminating null-character is not copied to the stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C string with the content to be written to stream. </td></tr>
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a non-negative value is returned. On error, the function returns EOF and sets the error indicator. </dd></dl>

</div>
</div>
<a id="afb8cb08b18c9b9ed78d1598c8076d956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8cb08b18c9b9ed78d1598c8076d956">&#9670;&nbsp;</a></span>fread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a> fread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read block of data from stream. </p>
<p>Reads an array of count elements, each one with a size of size bytes, from the stream and stores them in the block of memory specified by ptr. The position indicator of the stream is advanced by the total amount of bytes read. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to a block of memory with a size of at least (size*count) bytes, converted to a void*. </td></tr>
    <tr><td class="paramname">size</td><td>Size, in bytes, of each element to be read. </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements, each one with a size of size bytes. </td></tr>
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of elements successfully read is returned. If this number differs from the count parameter, either a reading error occurred or the end-of-file was reached while reading. In both cases, the proper indicator is set. </dd></dl>

</div>
</div>
<a id="a7f86d3747887e65d7d02e4792030fad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f86d3747887e65d7d02e4792030fad0">&#9670;&nbsp;</a></span>freopen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_f_i_l_e.html">FILE</a>* freopen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reopen stream with different file or mode. </p>
<p>Reuses stream to either open the file specified by filename or to change its access mode. If filename is a null pointer, the function attempts to change the mode of the stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>C string containing the name of the file to be opened. </td></tr>
    <tr><td class="paramname">mode</td><td>C string containing a file access mode (r, w, a, r+, w+, a+). </td></tr>
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be reopened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the file is successfully reopened, the function returns the pointer passed as parameter stream, which can be used to identify the reopened stream. Otherwise, a null pointer is returned. </dd></dl>

</div>
</div>
<a id="af2b5e837a27524264f0422232f5f9538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b5e837a27524264f0422232f5f9538">&#9670;&nbsp;</a></span>fseek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fseek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reposition stream position indicator. </p>
<p>Sets the position indicator associated with the stream to a new position. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
    <tr><td class="paramname">offset</td><td>Number of bytes to offset from origin. </td></tr>
    <tr><td class="paramname">origin</td><td>Position used as reference for the offset. It is specified by one of the constants (file begin: SEEK_SET, current position: SEEK_CUR, end of file: SEEK_END). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, the function returns zero. Otherwise, it returns non-zero value and error indicator is set. </dd></dl>

</div>
</div>
<a id="a76eb887fc5fbc842c2fb977dd926848c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76eb887fc5fbc842c2fb977dd926848c">&#9670;&nbsp;</a></span>fsetpos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fsetpos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="stdio_8h.html#a8d8024575832cf578e21406fbb1a7dc2">fpos_t</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set position indicator of stream. </p>
<p>Restores the current position in the stream to pos. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
    <tr><td class="paramname">pos</td><td>Pointer to a fpos_t object containing a position previously obtained with fgetpos. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, the function returns zero. On failure, a non-zero value is returned and errno is set to a system-specific positive value. </dd></dl>

</div>
</div>
<a id="a6273f71322efc95f429d9e990a8ef8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6273f71322efc95f429d9e990a8ef8ae">&#9670;&nbsp;</a></span>ftell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int ftell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current position in stream. </p>
<p>Returns the current value of the position indicator of the stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the current value of the position indicator is returned. On failure, -1 is returned, and errno is set to a system-specific positive value. </dd></dl>

</div>
</div>
<a id="a998dde93aaae1ed6cc10a4656eb5cc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998dde93aaae1ed6cc10a4656eb5cc10">&#9670;&nbsp;</a></span>fwrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a> fwrite </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write block of data to stream. </p>
<p>Writes an array of count elements, each one with a size of size bytes, from the block of memory pointed by ptr to the current position in the stream. The position indicator of the stream is advanced by the total number of bytes written. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to a block of memory with a size of at least (size*count) bytes, converted to a void*. </td></tr>
    <tr><td class="paramname">size</td><td>Size, in bytes, of each element to be read. </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements, each one with a size of size bytes. </td></tr>
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of elements successfully written is returned. If this number differs from the count parameter, a writing error prevented the function from completing. In this case, the error indicator will be set for the stream. </dd></dl>

</div>
</div>
<a id="ad5a0ea2c21a23a380b7c30fe35fa9456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a0ea2c21a23a380b7c30fe35fa9456">&#9670;&nbsp;</a></span>getc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get character from stream. </p>
<p>Returns the character currently pointed by the internal file position indicator of the specified stream. The internal file position indicator is then advanced to the next character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the character read is returned. If the position indicator was at the end-of-file, the function returns EOF. </dd></dl>

</div>
</div>
<a id="ac45fdeab51c3197c1e7c4ec7beabaca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45fdeab51c3197c1e7c4ec7beabaca9">&#9670;&nbsp;</a></span>getchar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getchar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get character from stdin. </p>
<p>Returns the next character from the standard input. </p><dl class="section return"><dt>Returns</dt><dd>On success, the character read is returned. If the position indicator was at the end-of-file, the function returns EOF. </dd></dl>

</div>
</div>
<a id="ad23cf6ce344e3cdbbe53eee7e9a83b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23cf6ce344e3cdbbe53eee7e9a83b5c">&#9670;&nbsp;</a></span>gets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* gets </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get string from stdin. </p>
<p>Reads characters from the standard input (stdin) and stores them as a C string into str until a newline character or the end-of-file is reached. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to a block of memory (array of char) where the string read is copied as a C string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the character read is returned. If the position indicator was at the end-of-file, the function returns EOF. </dd></dl>

</div>
</div>
<a id="af38eb7b0b01f7de79166633fd2fe0459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38eb7b0b01f7de79166633fd2fe0459">&#9670;&nbsp;</a></span>perror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void perror </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print error message. </p>

</div>
</div>
<a id="a98631211a4a8aee62f572375d5b637be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98631211a4a8aee62f572375d5b637be">&#9670;&nbsp;</a></span>printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print formatted data to stdout. </p>
<p>Writes the C string pointed by format to the standard output (stdout). If format includes format specifiers (subsequences beginning with %), the additional arguments following format are formatted and inserted in the resulting string replacing their respective specifiers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>String that contains text to be written to stdout. Can contain embedded format specifiers. </td></tr>
    <tr><td class="paramname">...</td><td>Additional arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of characters written to stdout </dd></dl>

</div>
</div>
<a id="afe402db9691d3b23117e664ddef88baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe402db9691d3b23117e664ddef88baa">&#9670;&nbsp;</a></span>putc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int putc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write character to stream. </p>
<p>Writes a character to the stream and advances the position indicator. The character is written at the position indicated by the internal position indicator of the stream, which is then automatically advanced by one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The int promotion of the character to be written. </td></tr>
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the character written is returned. If a writing error occurs, EOF is returned and the error indicator is set. </dd></dl>

</div>
</div>
<a id="afb174a8122023129dc9abbbed04d88fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb174a8122023129dc9abbbed04d88fd">&#9670;&nbsp;</a></span>putchar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int putchar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write character to stdout. </p>
<p>Writes a character to the standard output (stdout). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The int promotion of the character to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the character written is returned. If a writing error occurs, EOF is returned and the error indicator is set. </dd></dl>

</div>
</div>
<a id="a24df0c04767d20bfc8337baa088605ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24df0c04767d20bfc8337baa088605ff">&#9670;&nbsp;</a></span>puts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int puts </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write string to stdout. </p>
<p>Writes the C string pointed by str to the standard output (stdout) and appends a newline character ('<br />
'). The function begins copying from the address specified (str) until it reaches the terminating null character ('\0'). This terminating null-character is not copied to the stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C string to be printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the character written is returned. If a writing error occurs, EOF is returned and the error indicator is set. </dd></dl>

</div>
</div>
<a id="a2ff9908f035aec76a33f9792faf9d402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff9908f035aec76a33f9792faf9d402">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int remove </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove file. </p>

</div>
</div>
<a id="affd46c92931ef1c646e1a78ab880a00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd46c92931ef1c646e1a78ab880a00e">&#9670;&nbsp;</a></span>rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>oldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename file. </p>

</div>
</div>
<a id="aa0cd401f198d33d9d01a9e8aa4026819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cd401f198d33d9d01a9e8aa4026819">&#9670;&nbsp;</a></span>rewind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rewind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set position of stream to the beginning. </p>
<p>Sets the position indicator associated with stream to the beginning of the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c48433db9c04031772d5b36e6c4411d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c48433db9c04031772d5b36e6c4411d">&#9670;&nbsp;</a></span>scanf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scanf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read formatted data from stdin. </p>
<p>Reads data from stdin and stores them according to the parameter format into the locations pointed by the additional arguments. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>C string that contains the text to be written to the stream.Can contain embedded format specifiers. </td></tr>
    <tr><td class="paramname">...</td><td>Depending on the format string, the function may expect a sequence of additional arguments, each containing a pointer to allocated storage where the interpretation of the extracted characters is stored with the appropriate type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the function returns the number of items of the argument list successfully filled. Otherwise, EOF. </dd></dl>

</div>
</div>
<a id="ad886fefb32f6ec9ad47122fe5dfd916d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad886fefb32f6ec9ad47122fe5dfd916d">&#9670;&nbsp;</a></span>setbuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set stream buffer. </p>
<p>Specifies the buffer to be used by the stream for I/O operations, which becomes a fully buffered stream. Or, alternatively, if buffer is a null pointer, buffering is disabled for the stream, which becomes an unbuffered stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
    <tr><td class="paramname">buffer</td><td>User allocated buffer. Shall be at least BUFSIZ bytes long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92132979bde440e7f335dc6b030eded0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92132979bde440e7f335dc6b030eded0">&#9670;&nbsp;</a></span>setvbuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setvbuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdio_8h.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change stream buffering. </p>
<p>Specifies a buffer for stream. The function allows to specify the mode and size of the buffer (in bytes). If buffer is a null pointer, the function automatically allocates a buffer (using size as a hint on the size to use). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
    <tr><td class="paramname">buffer</td><td>User allocated buffer. Shall be at least BUFSIZ bytes long. </td></tr>
    <tr><td class="paramname">mode</td><td>Specifies a mode for file buffering (full buffering: _IOFBF, line buffering: _IOLBF, no buffering: _IONBF). </td></tr>
    <tr><td class="paramname">size</td><td>User allocated buffer. Shall be at least BUFSIZ bytes long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the buffer is correctly assigned to the file, a zero value is returned. Otherwise, a non-zero value is returned. </dd></dl>

</div>
</div>
<a id="a3082155ec11e7229f7a20439b31a169e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3082155ec11e7229f7a20439b31a169e">&#9670;&nbsp;</a></span>sprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write formatted data to string. </p>
<p>Composes a string with the same text that would be printed if format was used on printf, but instead of being printed, the content is stored as a C string in the buffer pointed by str. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to a buffer where the resulting C-string is stored. The buffer should be large enough to contain the resulting string. </td></tr>
    <tr><td class="paramname">format</td><td>String that contains text to be written to buffer. Can contain embedded format specifiers. </td></tr>
    <tr><td class="paramname">...</td><td>Additional arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of characters written to buffer </dd></dl>

</div>
</div>
<a id="ad77a6a7c369c033e56b15696cc5d2415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77a6a7c369c033e56b15696cc5d2415">&#9670;&nbsp;</a></span>ungetc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ungetc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unget character from stream. </p>
<p>A character is virtually put back into an input stream, decreasing its internal file position as if a previous getc operation was undone. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The int promotion of the character to be written. </td></tr>
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies the stream to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the character put back is returned. If the operation fails, EOF is returned. </dd></dl>

</div>
</div>
<a id="a238ba3ae728d117984e087d9db33cd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238ba3ae728d117984e087d9db33cd13">&#9670;&nbsp;</a></span>vfprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfprintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print formatted data from variable argument list to stream. </p>
<p>Writes the C string pointed by format to the stream. If format includes format specifiers (subsequences beginning with %), the additional arguments stored in arg list are formatted and inserted in the resulting string replacing their respective specifiers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies an output stream. </td></tr>
    <tr><td class="paramname">format</td><td>C string that contains the text to be written to the stream.Can contain embedded format specifiers. </td></tr>
    <tr><td class="paramname">arg</td><td>A value identifying a variable arguments list initialized with va_start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of characters written to stream. </dd></dl>

</div>
</div>
<a id="aadb0fd1f97e393175a27829805cbff92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb0fd1f97e393175a27829805cbff92">&#9670;&nbsp;</a></span>vfscanf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfscanf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_i_l_e.html">FILE</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read formatted data from stream into variable argument list. </p>
<p>Reads data from the stream and stores them according to parameter format into the locations pointed by the elements in the variable argument list identified by arg. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Pointer to a <a class="el" href="struct_f_i_l_e.html" title="Object containing information to control a stream. ">FILE</a> object that identifies an input stream. </td></tr>
    <tr><td class="paramname">format</td><td>C string that contains the text to be written to the stream.Can contain embedded format specifiers. </td></tr>
    <tr><td class="paramname">arg</td><td>A value identifying a variable arguments list initialized with va_start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the function returns the number of items of the argument list successfully filled. Otherwise, EOF. </dd></dl>

</div>
</div>
<a id="a2b037e5e1db404842a42cd8e9cecaddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b037e5e1db404842a42cd8e9cecaddb">&#9670;&nbsp;</a></span>vprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vprintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print formatted data from variable argument list to stdout. </p>
<p>Writes the C string pointed by format to the stream. If format includes format specifiers (subsequences beginning with %), the additional arguments stored in arg list are formatted and inserted in the resulting string replacing their respective specifiers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>C string that contains the text to be written to the stream.Can contain embedded format specifiers. </td></tr>
    <tr><td class="paramname">arg</td><td>A value identifying a variable arguments list initialized with va_start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of characters written to stream. </dd></dl>

</div>
</div>
<a id="ade8cce030b12942981147c40e4c77b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8cce030b12942981147c40e4c77b37">&#9670;&nbsp;</a></span>vsprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vsprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print formatted data from variable argument list to string. </p>
<p>Composes a string with the same text that would be printed if format was used on printf, but using the elements in the variable argument list identified by arg instead of additional function arguments and storing the resulting content as a C string in the buffer pointed by str. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to a buffer where the resulting C-string is stored. The buffer should be large enough to contain the resulting string. </td></tr>
    <tr><td class="paramname">format</td><td>C string that contains the text to be written to the stream.Can contain embedded format specifiers. </td></tr>
    <tr><td class="paramname">arg</td><td>A value identifying a variable arguments list initialized with va_start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of characters written to stream. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac9e47c346a25e2e7edd2c9b4ca5d0262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e47c346a25e2e7edd2c9b4ca5d0262">&#9670;&nbsp;</a></span>stderr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_f_i_l_e.html">FILE</a>* stderr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard error output (default is console). </p>

</div>
</div>
<a id="acab9c1fe2a80b10e01858bda28a04244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab9c1fe2a80b10e01858bda28a04244">&#9670;&nbsp;</a></span>stdin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_f_i_l_e.html">FILE</a>* stdin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard input (default is keyboard). </p>

</div>
</div>
<a id="ac80f4484175bf6c48d7b7ca4e9897ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80f4484175bf6c48d7b7ca4e9897ae6">&#9670;&nbsp;</a></span>stdout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_f_i_l_e.html">FILE</a>* stdout</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard output (default is console). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_e3d620c6b6fdb93ed3bc6186215bde2e.html">library</a></li><li class="navelem"><a class="el" href="dir_255fa8f554e95a439f260058328638ab.html">src</a></li><li class="navelem"><a class="el" href="stdio_8h.html">stdio.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
